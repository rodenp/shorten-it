
import { DB_TYPE, clientPromise, pool } from '@/lib/db';
import { Collection, Db, ObjectId } from 'mongodb'; // Ensure ObjectId is imported

export interface User {
  id?: string; // Optional for MongoDB as _id will be used
  _id?: ObjectId; // MongoDB specific ID
  name?: string | null;
  email?: string | null;
  emailVerified?: Date | null;
  image?: string | null;
  password?: string | null; // Hashed password
  createdAt?: Date;
  updatedAt?: Date;
}

// For MongoDB
let usersCollection: Collection<User> | null = null;

async function getMongoUsersCollection(): Promise<Collection<User>> {
  if (usersCollection) {
    return usersCollection;
  }
  if (!clientPromise) {
    throw new Error('MongoDB client promise not initialized');
  }
  const client = await clientPromise;
  const db: Db = client.db(); // Use default DB or specify one e.g. client.db("yourDbName")
  usersCollection = db.collection<User>('users');
  // Create indexes for MongoDB
  await usersCollection.createIndex({ email: 1 }, { unique: true, sparse: true });
  return usersCollection;
}

// User model functions
export const UserModel = {
  async findByEmail(email: string): Promise<User | null> {
    if (DB_TYPE === 'mongodb') {
      const collection = await getMongoUsersCollection();
      return collection.findOne({ email });
    } else if (DB_TYPE === 'postgres') {
      if (!pool) throw new Error('PostgreSQL pool not initialized.');
      const res = await pool.query('SELECT * FROM users WHERE email = $1', [email]);
      return res.rows[0] || null;
    }
    throw new Error('Unsupported DB_TYPE');
  },

  async findById(id: string): Promise<User | null> {
    if (DB_TYPE === 'mongodb') {
      const collection = await getMongoUsersCollection();
      if (!ObjectId.isValid(id)) return null; // Check if ID is a valid ObjectId string
      return collection.findOne({ _id: new ObjectId(id) });
    } else if (DB_TYPE === 'postgres') {
      if (!pool) throw new Error('PostgreSQL pool not initialized.');
      const res = await pool.query('SELECT * FROM users WHERE id = $1', [id]);
      return res.rows[0] || null;
    }
    throw new Error('Unsupported DB_TYPE');
  },

  async create(data: Omit<User, 'id' | '_id' | 'createdAt' | 'updatedAt'>): Promise<User> {
    if (DB_TYPE === 'mongodb') {
      const collection = await getMongoUsersCollection();
      const now = new Date();
      const result = await collection.insertOne({
        ...data,
        createdAt: now,
        updatedAt: now,
      });
      const insertedDoc = await collection.findOne({ _id: result.insertedId });
      if (!insertedDoc) throw new Error('Failed to retrieve created user from MongoDB');
      // Map _id to id for consistency if needed by NextAuth adapter
      return { ...insertedDoc, id: insertedDoc._id.toHexString() };
    } else if (DB_TYPE === 'postgres') {
      if (!pool) throw new Error('PostgreSQL pool not initialized.');
      const now = new Date();
      // For Postgres, id is usually auto-generated (e.g., UUID) or needs to be provided
      // Assuming id is provided or generated by DB extension like pgcrypto for uuid_generate_v4()
      // For this example, let's assume id is text and we generate one here.
      const newId = new ObjectId().toHexString(); // Simple unique ID, or use uuid
      const res = await pool.query(
        'INSERT INTO users (id, name, email, password, "createdAt", "updatedAt") VALUES ($1, $2, $3, $4, $5, $6) RETURNING *',
        [newId, data.name, data.email, data.password, now, now]
      );
      return res.rows[0];
    }
    throw new Error('Unsupported DB_TYPE');
  },
  // Add other CRUD operations as needed (updateUser, deleteUser, etc.)
};
